package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"back/domain/constant"
	"back/domain/entity"
	"back/infrastructure/repository"
	"back/infrastructure/request"
	"back/usecase"
	"bytes"
	"context"
	"io"

	"github.com/99designs/gqlgen/graphql"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, name *string, accountCode *string, password *string, imageFile *graphql.Upload) (*entity.MutationResponse, error) {
	req := request.UpdateUserRequest{}
	if name != nil {
		req.Name = *name
	}
	if accountCode != nil {
		req.AccountCode = *accountCode
	}
	if password != nil {
		req.Password = *password
	}
	if imageFile != nil {
		req.File = imageFile.File
		req.ContentType = imageFile.ContentType
	}
	msgs, ok := req.Validate()
	if !ok {
		return &entity.MutationResponse{
			Success:  false,
			Messages: msgs,
		}, nil
	}

	authUser := ctx.Value(constant.AUTH_USER_KEY).(*entity.UserEntity)
	orm := r.Resolver.Orm
	storage := r.Resolver.Storage

	updateUserUsecase := usecase.NewUpdateUserUsecase(
		repository.NewUserRepository(orm),
		repository.NewFileRepository(storage),
	)

	var file io.ReadSeeker
	var contentType *string
	if imageFile != nil {
		buf := new(bytes.Buffer)
		if _, err := io.Copy(buf, imageFile.File); err != nil {
			return nil, err
		}
		file = bytes.NewReader(buf.Bytes())
		contentType = &imageFile.ContentType
	}

	_, err := updateUserUsecase.Execute(
		authUser,
		name,
		accountCode,
		password,
		file,
		contentType,
	)
	if err != nil {
		return &entity.MutationResponse{
			Success:  false,
			Messages: []string{err.Message},
		}, nil
	}

	return &entity.MutationResponse{
		Success: true,
		Messages: []string{
			"ユーザー情報を更新しました",
		},
	}, nil
}
