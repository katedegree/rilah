package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"back/domain/entity"
	"back/infrastructure/repository"
	"back/infrastructure/request"
	"back/usecase"
	"bytes"
	"context"
	"io"

	"github.com/99designs/gqlgen/graphql"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, name *string, accountCode *string, password *string, imageFile *graphql.Upload) (*entity.MutationResponse, error) {
	var file io.ReadSeeker = nil
	var contentType string = ""
	if imageFile != nil {
		file = imageFile.File
		contentType = imageFile.ContentType
	}

	req := request.NewUpdateUserRequest(name, accountCode, password, file, contentType)
	msgs, ok := req.Validate(r.Validator)
	if !ok {
		return &entity.MutationResponse{
			Success:  false,
			Messages: msgs,
		}, nil
	}

	authUser := r.Resolver.AuthUserContext.Get(ctx)
	orm := r.Resolver.Orm
	storage := r.Resolver.Storage

	updateUserUsecase := usecase.NewUpdateUserUsecase(
		repository.NewUserRepository(orm),
		repository.NewFileRepository(storage),
	)

	if imageFile != nil {
		buf := new(bytes.Buffer)
		if _, err := io.Copy(buf, imageFile.File); err != nil {
			return nil, err
		}
		file = bytes.NewReader(buf.Bytes())
		contentType = imageFile.ContentType
	}

	err := updateUserUsecase.Execute(
		authUser,
		name,
		accountCode,
		password,
		file,
		&contentType,
	)
	if err != nil {
		return &entity.MutationResponse{
			Success:  false,
			Messages: []string{err.Message},
		}, nil
	}

	return &entity.MutationResponse{
		Success: true,
		Messages: []string{
			"ユーザー情報を更新しました",
		},
	}, nil
}
